#!/usr/bin/env node
/**
 * test-utils/auth.mjs
 * JWT token generation utility for tests
 * Provides functions to create valid JWT tokens for testing authentication
 */

import fs from 'fs';
import path from 'path';
import jwt from 'jsonwebtoken';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..');

/**
 * Find the latest private key file generated by setup-local-auth
 */
function getPrivateKey() {
  const files = fs.readdirSync(projectRoot).filter(f => /^private-[a-f0-9]+\.pem$/.test(f));
  if (!files.length) {
    throw new Error('No private-<kid>.pem found. Run `node scripts/setup-local-auth.cjs` first.');
  }
  
  // Pick newest by modification time
  const withTime = files.map(f => ({ 
    file: f, 
    time: fs.statSync(path.join(projectRoot, f)).mtimeMs 
  }));
  withTime.sort((a, b) => b.time - a.time);
  
  const latestFile = withTime[0].file;
  const kid = latestFile.replace(/^private-([a-f0-9]+)\.pem$/, '$1');
  const key = fs.readFileSync(path.join(projectRoot, latestFile), 'utf8');
  
  return { kid, key };
}

/**
 * Generate a JWT token for testing
 * @param {Object} options - Token options
 * @param {string} [options.sub='test-user'] - Subject (user ID)
 * @param {string[]} [options.roles=['editor']] - User roles
 * @param {string} [options.tenantId] - Tenant ID
 * @param {string} [options.appId] - Application ID
 * @param {string} [options.expiresIn='1h'] - Token expiration
 * @param {string} [options.issuer] - Token issuer (defaults to .env AUTH_ISSUER)
 * @param {string} [options.audience] - Token audience (defaults to .env AUTH_AUDIENCE)
 * @returns {string} JWT token
 */
export function generateTestToken(options = {}) {
  const {
    sub = 'test-user',
    roles = ['editor'],
    tenantId,
    appId,
    expiresIn = '1h',
    issuer = process.env.AUTH_ISSUER || 'http://localhost:3100',
    audience = process.env.AUTH_AUDIENCE || 'mail-service'
  } = options;

  const { kid, key } = getPrivateKey();
  
  const payload = { sub, roles };
  if (tenantId) payload.tenantId = tenantId;
  if (appId) payload.appId = appId;

  return jwt.sign(payload, key, {
    algorithm: 'RS256',
    issuer,
    audience,
    expiresIn,
    header: { kid }
  });
}

/**
 * Generate an Authorization header with Bearer token
 * @param {Object} options - Token options (same as generateTestToken)
 * @returns {Object} Headers object with Authorization
 */
export function getAuthHeaders(options = {}) {
  const token = generateTestToken(options);
  return {
    'Authorization': `Bearer ${token}`
  };
}

/**
 * Check if the API requires authentication by making a test request
 * @param {string} [baseUrl='http://localhost:3100'] - API base URL
 * @returns {Promise<boolean>} True if authentication is required
 */
export async function isAuthRequired(baseUrl = 'http://localhost:3100') {
  try {
    const response = await fetch(`${baseUrl}/send-now`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ appId: 'test' })
    });
    
    // If we get 401, auth is required
    // If we get anything else (400, 500, etc.), auth is not required
    return response.status === 401;
  } catch (error) {
    console.warn('Could not determine auth status:', error.message);
    return false; // Assume no auth if we can't reach the server
  }
}

/**
 * Get headers with authentication if required, or empty headers if not
 * @param {Object} options - Token options (same as generateTestToken)
 * @param {string} [baseUrl='http://localhost:3100'] - API base URL
 * @returns {Promise<Object>} Headers object with or without Authorization
 */
export async function getAdaptiveHeaders(options = {}, baseUrl = 'http://localhost:3100') {
  const authRequired = await isAuthRequired(baseUrl);
  if (authRequired) {
    console.log('🔐 Authentication required - using JWT token');
    return getAuthHeaders(options);
  } else {
    console.log('🔓 Authentication disabled - no token needed');
    return {};
  }
}

/**
 * Predefined token types for common test scenarios
 */
export const testTokens = {
  // Admin user with all permissions
  admin: () => generateTestToken({ 
    sub: 'admin-user', 
    roles: ['admin', 'editor'] 
  }),
  
  // Editor user with basic permissions
  editor: () => generateTestToken({ 
    sub: 'editor-user', 
    roles: ['editor'] 
  }),
  
  // User with specific tenant access
  tenantUser: (tenantId) => generateTestToken({ 
    sub: 'tenant-user', 
    roles: ['editor'], 
    tenantId 
  }),
  
  // User with specific app access
  appUser: (appId) => generateTestToken({ 
    sub: 'app-user', 
    roles: ['editor'], 
    appId 
  }),
  
  // User with both tenant and app access
  fullAccess: (tenantId, appId) => generateTestToken({ 
    sub: 'full-user', 
    roles: ['admin'], 
    tenantId, 
    appId 
  }),
  
  // Expired token for testing authentication failures
  expired: () => generateTestToken({ 
    sub: 'expired-user', 
    roles: ['editor'], 
    expiresIn: '-1h' // Already expired
  })
};

/**
 * CLI interface - if this file is run directly, generate a token
 */
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const options = {};
  
  for (let i = 0; i < args.length; i++) {
    if (args[i].startsWith('--')) {
      const key = args[i].substring(2);
      const value = args[i + 1] && !args[i + 1].startsWith('--') ? args[++i] : 'true';
      
      if (key === 'roles') {
        options[key] = value.split(',');
      } else {
        options[key] = value === 'true' ? true : value;
      }
    }
  }
  
  try {
    const token = generateTestToken(options);
    console.log(token);
  } catch (error) {
    console.error('Error generating token:', error.message);
    process.exit(1);
  }
}